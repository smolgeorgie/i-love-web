# RECAP YEAR 1

## Node.js Recap

*Node.js*: A JavaScript runtime environment that executes JavaScript code outside of a web browser. It's used to build server-side applications.
*Server-side rendering (SSR)*: A technique where the server generates the HTML content of a web page before sending it to the client, improving initial page load performance and SEO.

## Directus

*Headless CMS*: A content management system that focuses on managing content and data, without providing a built-in frontend.
*Models*: Data structures that define the organization and relationships between different data types.


# WHAT TO EXPECT YEAR 2

## **SvelteKit**

*Svelte*: A component-based framework for building user interfaces, known for its efficient compilation process.
*SvelteKit*: A full-stack framework built on Svelte, providing features like server-side rendering, code splitting, and routing.
*Hydration*: The process of transforming static HTML generated by the server into an interactive Svelte application on the client side.
*SSR-only mode*: A configuration where SvelteKit only renders the initial page on the server, and subsequent interactions are handled entirely on the client.

## Imporant information for whats coming 

### **Hosting**: 
We're using Vercel or Netlify for hosting our application. These platforms offer convenient deployment and management features.

### **Project Structure**: 
**Static folder**: Similar to the public folder in EJS, this folder contains static assets like images, CSS, and JavaScript files.
**Src folder**: The main development directory where our application's code resides.
app.html: The main HTML file for the application. You can customize it for specific needs like adding global styles or meta tags.

### **SvelteKit Features**: 
**Data-sveltekit-preload-data="hover"**: This attribute preloads the content of a linked page when the user hovers over the link, improving the user experience on desktop devices.

### **Code Organization**: 
**lib folder**: A dedicated folder for storing reusable components, promoting code organization and reusability.

### **Additional Notes**:
**Server-side rendering (SSR)**: We're starting without SSR for simplicity, but we can add it later if needed for performance or SEO benefits.
**Component-based development**: SvelteKit encourages a component-based approach, making it easier to build modular and maintainable applications.

## What's expected from us

#### **Visit Cards (Year 1)**

* **Mentoring Roles**
  * Guide 1st-year students once a week.
  * Help them understand web technologies, dev cycles, and ZPD.
  * Assist with appropriate tasks, providing minimal hints.
  * Provide feedback on visit cards via GitHub issues.

#### **Learning Journal / I love web**

* **Logbook:** Keep track of your learning journey.
* **Avoid** using a wiki.
* **Create:** `.md` files and convert them to HTML with 11ty.
* **Showcase:** Use your learning journal as a website to demonstrate your skills.

#### **Feedback Squadpage (team)**

* **2 rounds of feedback** on the squadpage.
* **D.o.D.s:** Refer to the same DoD's from Sprint 12.
* **Feedback process:**
  * Sit with your team and finalize details.
  * Conduct 15-minute feedback exchanges with the adjacent table.
  * Rotate to the next table (clockwise).

#### **Open Brainstorm Visit Card (team)**

* **Start date:** Monday
* **Brainstorming:** Conduct brainstorming rounds via GitHub issues


# FIGMA WORKSHOPS - KILL YOUR DARLINGS

## **Tips for Figma - How to start**

* Make screenshots from designs you like and put them in your Figma file as reference. You can use LinkedIn, Instagram, Pinterest, or Dribble for inspiration. 
* Make sketches that you can use as a base for your design. You can implement things from your screenshots for new ideas or featuers. 
* Create an assets folder in Figma where you can store all your icons, images, and other assets. This way, you can easily reuse them in your designs.

## **Tips and Tricks**

* Do not use too many different fonts. Stick to 2-3 fonts for your design.
* Line height is really important. Use 120% or 1.2em for a good line height.
* Use the same spacing between elements. This will make your design look more consistent.
* Use the same colors for the same elements. For example, use the same color for all buttons. Make some variations, but keep the same color scheme. 

# CREATIVE CODING WITH SVELTEKIT - JUSTUS

creative coding = progressive enhancement = content first - content = html, server side rendering.

## **Creative Coding**

**scroll-snap-type**: x-mandatory; locks scrolling horizontally, ensuring content snaps to predefined positions. This is a non-breaking enhancement. If someone has a browser that doesn't support this, they can still scroll normally, but they won't have the scroll snap effect.

**Tip**: 
* Be sure to check the SvelteKit documentation, as not everything works the same way in SvelteKit as in plain CSS!
* Documents don't exist in SvelteKit (on the server-side, JS). Use the onMount function on the client-side for this.


## **CSS properties**: 

```
ul { scroll-snap-type: x mandatory; }
ul li { scroll-snap-align: center; }```
```

```css
@supports (animation-timeline: scroll()) {
  ul li {
    view-timeline-name: "My Timeline";
    view-timelines-axis: horizontal;
    view-timeline-inset: 20px;
    animation-range: 0s to 10s;
  }
}
```

==Do the SvelteKit tutorial. `-csr = false` turns off Client Side Rendering i.o.w Turns JavaScript off==

# WORKING TOGETHER, PRIORITIES AND TIME MANAGEMENT

## **Epics**
**Definition**: Large, overarching work packages that represent a significant goal.Purpose:

* Break down work into manageable chunks.
* Deliver value to customers regularly.
* Keep teams focused on a larger goal.

**Examples**:
* Launch a new e-commerce website.
* Improve an existing website.
* Implement augmented reality.

## **Stories** 
**Definition**: Smaller, more specific work packages that are part of an Epic.Purpose:

* Further break down Epics into more concrete tasks.
* Better plan and estimate work.Examples:
* Add a shopping cart to an e-commerce website.
* Make a website faster.

## **User Stories**
**Definition**: Descriptions of a feature from the end-user's perspective.

**Purpose**:
* Make requirements more concrete.
* Ensure development stays focused on user needs.**Format**: As a [type of user], I want [goal], so that [reason]. **Example**: As a visitor, I want to be able to add products to my shopping cart, so that I can keep track of my purchases.

## **Relationship between Epics, Stories, and User Stories**
**Epic → Stories**: An Epic is broken down into multiple Stories.
**Story → User Stories** : A Story can be further elaborated into multiple User Stories.

## **Example: Adding a Shopping Cart**
**Epic**: Launch a new e-commerce website.
**Story**: Add a shopping cart.
**<li>User Stories:</li>**
<ul><li> As a visitor, I want to be able to add products to my shopping cart.</li>
<li>As a visitor, I want to be able to remove products from my shopping cart.</li><
... 
</ul>
<br>
<li>Tasks:</li>
<ul> <li> Create a database for the shopping cart.</li>
<li> Design the shopping cart interface.</li>
</ul>
<br>

**Visual**:
```
Codefragment<br>
flowchart LR
  A(Epic) --> B{Story}
  B --> C{User Story}
  C --> D{Task}
  ```

## **Planning Poker for time estimation**
Consensus-based technique for estimating the effort required to complete a task. Planning Poker involves team members selecting a card that represents their estimate of the task's complexity. The team then discusses the estimates and repeats the process until a consensus is reached. This can variate per number, like 1, 2, 3, 5, 8, 13, 24, 40 etc. 

## ** Prioritization Techniques**
**MoSCoW Method**: Prioritizes tasks based on their importance and urgency. Tasks are categorized as Must-haves, Should-haves, Could-haves, and Won't-haves.

## **Summary**
By using Epics, Stories, and User Stories, teams can approach large projects in a structured and efficient manner. This approach ensures that all stakeholders have a clear understanding of what needs to be done and why.











